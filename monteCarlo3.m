function [prob]=monteCarlo3(N)
number=0;  %初始化T1,T2,T3这3个候选人都被选中的次数
for i=1:N         %进行蒙特卡洛N次模拟
A=zeros(26,16);   %生成一个26行16列的矩阵，用来保存26个公平评审人的投票结果
B=zeros(5,16);    %生成一个5行16列的矩阵，用来保存5个有倾向评审人的投票结果
B(1:5,14:16)=5;   %5个有倾向的评审人对于T1，T2，T3这3个候选人的投票结果
%%%%%%%%%首先26个公平评审人进行投票
    for j=1:26    
        m=randperm(16,9);  %随机生成1:16中9个整数
        c=A(j,m);
        c(1:3)=c(1:3)+5;   %3张5分票
        c(4:6)=c(4:6)+3;   %3张3分票
        c(7:9)=c(7:9)+1;   %3张1分票
        A(j,m)=c;
    end
%%%%%%%%%%然后对5个有倾向性的评审人进行投票
    for h=1:5
        s=randperm(13,6);  %随机生成1:13中6个整数
        e=B(h,s);
        e(1:3)=e(1:3)+3;   %3张3分票
        e(4:6)=e(4:6)+1;   %3张1分票
        B(h,s)=e;
    end
    tps=sum(A)+sum(B);     %将每一个候选人获得的票数求和
    [f_result,ind]=sort(tps);    %对票数进行从低到高排序
    winner=ind(:,9:16);          %选取得票前8名的候选人的编号
    T=[14 15 16];                %T1的编号为14，T2的编号为15，T3的编号为16
    tf=ismember(T,winner);       %判断14,15,16是否在前八名的编号中
    if sum(tf,2)==3              %判断是否三个人都在前八名
        number=number+1;         %如果都在，那么次数加1
    end
end
prob=number/N;                   %求出T1,T2,T3这3个候选人都被选中的概率